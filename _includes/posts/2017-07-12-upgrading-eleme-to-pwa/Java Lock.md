# Java Lock

## 目的

Java Lock适用于内置锁解决不了的问题，而不是用于替换内置锁。它是内置锁的扩展。与内置加锁机制不同的是，Lock提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显式的。

lock必须显示的释放锁，如在finally块中释放。

## 内置锁

内置锁：又被称为监视器锁，每个对象都会持有的锁，Synchronized持有的锁。

作用：通过独占锁的方式保证同步代码块的原子性和内存可见性

**内存可见性**如何保证?

内存可见性的保证是因为两个线程都需要同一把锁才能执行某些操作，那么这些操作必然是串行的，串行则

获取：只能通过Synchronized获得，在同步代码块或同步代码方法中持有，

释放：一旦退出同步代码，无论是正常执行完成还是异常退出，锁都会被释放。

### 特点

可重入：如果一个线程尝试获取一个已经由它持有的锁，这个请求会成功。实质是**锁持有的操作粒度是“线程”而非 “调用”**。

实现方式：重入的一种实现方法是为每个锁关联一个计数器和持有锁的线程标识，当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM会记下锁的持有者，并把计数器加1，当该线程再次请求同一锁时，会继续讲计数器加1。当线程退出同步代码块时，计数器响应减1，当计数器为0时代表该锁被释放。

这样做提升了加锁行为的封装性，简化了面向对象开发代码的开发。例如当一个同步方法内部调用同一对象另一个同步方法，如果没有可重入，那么就会发生死锁。

## ReentrantLock

和synchronized相同的互斥性和内存可见性，以及可重入的