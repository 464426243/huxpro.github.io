## 面向对象和面向过程的区别

* 面向过程：面向过程更偏向硬件，例如C，汇编，对于简单的功能可以更快的实现，且有很高的复用性
* 面向对象：面向对象具有封装，继承，多态的特性，所以可以更好的对业务模型进行抽象，设计低耦合的系统对于复杂业务也可以编写更稳定更易于维护的代码。

## Java有哪些特点

* 平台无关性
* 半解释半编译语言
* 面向对象编程语言
* 安全可靠(强类型校验，程序沙盒化，异常机制)

## JVM JDK JRE

JVM（Java vitual machine） 它是运行Java字节码的虚拟机。Jvm在不同那个系统能够有不同实现，但可以保证相同的字节码，执行的结果都相同，即平台无关性。

什么是字节码？采用字节码的好处是什么？

在Java中，JVM可以理解的代码是字节码，Java文件编译后生成.class文件，该文件存的就是字节码。它不同于机器指令，不面向任何特定的处理器，只面向虚拟机。字节码保证了Java的平台无关性，同时也保证了Jvm的语言无关性，非Java的语言只要可以生成字节码就可以在Jvm上运行。

Java从源代码到运行一班有下面3步：

```
00					Javac编译
.Java文件 ==========> .class文件(二进制字节码，可以通过Javap查看)  

JVM
====>CPU可以执行的机器指令
```

.class ->机器码 这一步，Jvm有多种方式。JVM类加载器首先加载字节码文件，生成Class对象，然后再执行时通过解释器逐行解释执行，这种方式是一种典型的懒加载，在启动时比较快，但执行时会比较慢。因此为了提高性能而引入了JIT编译器(just-in-time compiler)。对于热点代码，即时编译器会会在完成第一次编译后，将字节码对应的机器码保存下来，同时也会进行一些方法内联，标量替换、公共子表达式提取等运行期优化。JDK 9 换引入了新的编译模式AOT(Ahead of time compilation)，JDK支持分层编译和AOT协同使用

总结

JVM是运行Java字节码的虚拟机。Jvm有针对不同系统的特定实现，目的是保证相同的字节码在不同的系统可以有相同的结果。Jvm保证了Java的平台无关性，同时还支持语言无关性。

JDK Java Development Kit Java开发组件。他是功能齐全的Java SDK。他拥有JRE所拥有的一切，患有编译器(Javac)和开发调试工具。

JRE Java Runtime Environment 包括JVM，java类库及其他基础组件，是运行已编译Java程序所需的所有内容的集合。一般来说，如果只需要运行Java程序，安装JRE就可以了。但不是绝对的，例如使用JSP部署Web应用程序那么就需要JDK。因为JSP在运行时动态生成Java servlet，并需要JDK编译Servlet

Oracle jdk和open jdk的区别

1. Open JDK是完全开源的，而Oracle jdk不是完全开源的。
2. Oracle公司为Oracle JDK提供某些商业功能的支持

Java和C++的区别

* 都是面向对象的语言，支持封装，继承和多台
* C++提供对C的兼容，因此保留了C的大量特性，包括指针等，而Java则没有这样的历史包袱，坚持一切皆对象的理念，这是二者本质的区别。
* Java有自动内存管理机制，不需要程序员手动释放无用内存

什么是Java程序的主类(main class) 应用程序和小程序的主类有何不同

一个程序中可以有多个类，但只能有一个类是主类，该类是Java程序执行的入口。在Java应用程序中，这个主类是包含main方法的类，而在java小程序(applet)中，这个类是继承自系统类JApplet或Applet的子类。

字符型常量和字符串常量的区别

* 表示上，字符串常量是单引号引起的一个字符，而字符创常量是双引号引起的若干个字符
* 含义上，字符常量表示一个2字节的整形值(Asciii码)，而字符串常量表示一串字符常量或者更丰富的Unicode字符
* 占用内存上，字符常量占2字节，字符串常量则不定

Java基本类型及内存大小

int 4 字节 32位有符号 整数

char 2 字节 16位 IUnicode字符 

byte 1 字节 8位 有符号 整数

short 2 字节 16位 有符号 整数 

long 8 字节 54位 有符号 整数

 double 8 字节 54位 有符号 双精度浮点数 

boolean 1 为 true、false

float 4字节 32位 有符号 单精度浮点数

构造器是否可被重写？

构造器不可以被重写，但可以被重载，因此你可以看到多个构造器，但需要注意的是，Java类默认会生成一个无参构造方法，但如果重载了一个有参构造方法，则该默认无参构造方法会被覆盖

重载和重写的区别

重载是同一个类中多个同名的方法根据入参的不同，做出不同的处理逻辑

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新实现。重写有以下几个特点

1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符大于等于父类修饰符。（遵循里氏替换原则，子类可以在任何地方替换父类，如果修饰符小于父类修饰符，抛出异常范围大于父类，那么该原则就无法达成了）
2. 如果父类方法访问修饰符为 private /final /static 则子类不能重写该方法，但是被static修饰的方法可以被再次声明。(父类static方法不会继承和重写，但子类可以重新声明，也可以访问父类的静态变量，是因为这些是类在编译期确定的，而重写发生在运行期)
3. 构造方法无法被重写

重载和重写的底层原理

前置知识

Java在编译过程会将方法生成符号引用，而不是运行时方法的入口(直接引用)，只有在类加载甚至真正运行时才会将符号引用转化成直接引用。

虚拟机在类加载的解析阶段，会将一部分符号引用转化成直接引用，因为这一部分方法JVM可以明确他的参数，方法名，返回值等。这部分方法被称为非虚方法，包括父类方法，静态方法，final方法和私有方法。因此，这些方法是不可以被重写的。

而对于非虚方法，Java是在运行时确定的，字节码为invokeVirual。该指令执行过程为

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C
2. 在C中寻找参数、返回结果、方法名都一致的方法，如果可以找到，则进行全县校验，如果成功，则返回该方法的直接引用，如果不成功，则抛出IllegalAccessError
3. 如果未找到，则寻找该类的父类，循环2
4. 如果始终未找到，则抛出AbstractMethodError

这就是重写为什么JVM会选择子类相关方法而不是父类方法的实质，被称为动态分派。

而重载的实现则是在编译期完成的，Java在编译时可以知道一个方法调用的参数类型，方法名，返回结果，就可以找到该方法正确的重载版本。当然，由于继承和自动装箱拆箱等情况的存在，编译器可能找到方法多个可能的重载版本，这时就会按约定的优先级找到一个版本，当然在开发中要避免实现这样的重载方法。、

重载和重写都是Java为实现多态而提供的特性。

Java面向对象编程三大特性

